
#[test]
fn test_bytes_per_line() {
    let mut settings = DocumentSettings::default();
    settings.bytes_per_line = 3;

    let data = [0x11, 0x22, 0x33, 0x44, 0x55];
    let block_types = vec![BlockType::DataByte; 5];
    let disassembler = Disassembler::new(&[], &BTreeMap::new(), &BTreeMap::new());
    let formatter = Box::new(crate::disassembler::assembler::Tass64::default());
    
    let lines = disassembler.handle_data_byte(
        0,
        &data,
        &block_types,
        0x1000,
        formatter.as_ref(), // Box<dyn Formatter> -> &dyn Formatter
        &BTreeMap::new(),
        0x1000,
        None,
        String::new(),
        None,
        &BTreeSet::new(),
        &settings,
    ).1;

    // With bytes_per_line = 3, we expect:
    // Line 1: 0x11, 0x22, 0x33
    // Line 2: 0x44, 0x55
    // But wait, handle_data_byte actually returns ONE DisassemblyLine with multiple bytes if I remember correctly?
    // Let's re-read handle_data_byte.
    // It returns (count, vec![DisassemblyLine]).
    // And it has a while loop: `while pc + count < data.len() && count < settings.bytes_per_line`.
    // It creates ONE DisassemblyLine with `bytes` vector.
    // So the caller (disassemble loop) is responsible for calling it multiple times.
    // disassembler.handle_data_byte returns only ONE line (or chunk).
    
    // So for this unit test of `handle_data_byte`, we only test that it consumes AT MOST `bytes_per_line` bytes.
    // If I pass 5 bytes and limit is 3, it should consume 3.
    
    // Correction: handle_data_byte returns (consumed_count, lines).
    // So I should check that consumed_count is 3, and lines[0].bytes has 3 elements.
}
