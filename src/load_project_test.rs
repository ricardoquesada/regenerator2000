#[cfg(test)]
mod tests {
    use crate::state::{AppState, Block, BlockType, DocumentSettings, LabelKind, ProjectState};
    use std::collections::HashMap;

    #[test]
    fn test_load_project_regenerates_auto_labels() {
        let mut app_state = AppState::new();

        // 1. Create a dummy project JSON
        // We need code that produces a label.
        // 4C 05 10  -> JMP $1005. Should generate auto label j1005 (or b1005 depending on logic, but definitely an auto label).
        // The project JSON will have NO labels map (empty).

        let _raw_data_hex = vec!["4C 05 10 EA EA".to_string()]; // JMP $1005, NOP, NOP. Origin 1000.
                                                                // 1000: 4C 05 10
                                                                // 1003: EA
                                                                // 1004: EA
                                                                // 1005: (End of file, but target is 1005).
                                                                // Wait, if target is 1005 and len is 5, origin 1000...
                                                                // 1000, 1001, 1002, 1003, 1004.
                                                                // 1005 is External if data len is 5.
                                                                // Let's make data len 6. "4C 05 10 EA EA EA".
                                                                // 1000..1005 (inclusive).

        let chunk = "4C 05 10 EA EA EA";

        let project = ProjectState {
            origin: 0x1000,
            raw_data: vec![chunk.to_string()],
            blocks: vec![Block {
                start: 0,
                end: 5,
                type_: BlockType::Code,
            }],
            labels: HashMap::new(), // EMPTY! No saved labels.
            settings: DocumentSettings::default(),
        };

        let json = serde_json::to_string(&project).unwrap();

        let mut path = std::env::temp_dir();
        path.push("test_regen_labels.regen2000proj");
        std::fs::write(&path, json).unwrap();

        // 2. Load it
        app_state
            .load_project(path.clone())
            .expect("Failed to load project");

        // 3. Verify labels exist
        // We expect a label at 0x1005.
        let label = app_state.labels.get(&0x1005);
        assert!(
            label.is_some(),
            "Autogenerated label at 0x1005 should exist after load"
        );
        let label = label.unwrap();
        assert_eq!(
            label.first().unwrap().kind,
            LabelKind::Auto,
            "Should be Auto label"
        );
        // Name might be j1005 or b1005 depending on priority, checking existence is main goal.

        // Cleanup
        let _ = std::fs::remove_file(path);
    }
}
